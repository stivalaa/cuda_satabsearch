#!/bin/sh
#
# File:    mktabrow.sh
# Author:  Alex Stivala
# Created: August 2008
#
# mktabrow.sh - make a row in the LaTeX table of results for a single
#               query to be used in thesis/paper. 
#
# Usage: mktabrow basefilename
#
# The basefilname is the basename of the file to use e.g.
# d1ubia_.tsrchn.orderpen0.typepen0
# from which we extract the scopsid as the first component (e.g. d1ubia_)
# and use basefilename.rtab, basefilename.err and ../data/scopsid.input
#
# Output is to stdout.
#
# Each row contains:
#
#            Fold & SCOP sid & \# SSEs & AUC & time\\
# e.g.
#            Immunoglobulin      & \texttt{d1ae6h1}  & 13 & 0.93 & 9:20  \\
#
# SCOP sid is first part of filename. #SSEs is obtained from input for
# that sid in data/ directory, AUC is obtained from .rtab generated
# for that sid by tsevalfn.py, time from the .err file for that sid.
# Run from the Makefile that builds the .rtab file as a prerequisite.
# The Fold is coded as a case statement in this script.
# 
# $Id: mktabrow.sh 1878 2008-09-08 07:59:32Z astivala $
#

# location of .out, .err and .rtab files
RESULTSDIR=.
# location of .input files (used for getting number of SSEs)
INPUTDIR=../data

if [ $# -ne 1 ]; then
    echo "Usage: $0 basefilename" 2>&1
    exit 1
fi

basefilename=$1

dotindex=`expr index ${basefilename} '.'`
dotindex=`expr ${dotindex} - 1`
scopsid=`expr substr ${basefilename} 1  ${dotindex}`

case ${scopsid} in
    d1ubia_)
    fold='$\beta$-grasp'
    ;;
    d1ae6h1)
    fold='Immunoglobulin'
    ;;
    d1tima_)
    fold='Tim-barrel'
    ;;
    d1bhne_)
    fold='Plait (ferredoxin)'
    ;;
    d1h6rb_)
    fold='GFP-like'
    ;;
    d1tttb1)
    fold='Key-barrel'
    ;;
    d2phlb1)
    fold='Jelly-roll'
    ;;
    d1f6dc_)
    fold='NAD-binding fold'
    ;;
    *)
    fold=`echo ${scopsid} | sed 's/_/\\\_/g'`
esac

rtabfile=${RESULTSDIR}/${basefilename}.rtab
inputfile=${INPUTDIR}/${scopsid}.input
errfile=${RESULTSDIR}/${basefilename}.err

auc=`tail ${rtabfile} | grep 'AUC = ' | cut -d' ' -f4`
numsses=`grep -i ${scopsid} ${inputfile} | awk '{print $2}'`

# assume times are in this sort of format, as generated by /usr/bin/time
# on Linux:
#49576.89user 2907.19system 14:45:02elapsed 98%CPU (0avgtext+0avgdata 0maxresident)k
#0inputs+0outputs (0major+504890689minor)pagefaults 0swaps
# or (for less than an hour):
#2603.51user 217.97system 47:10.00elapsed 99%CPU (0avgtext+0avgdata 0maxresident)k
#0inputs+0outputs (0major+26943522minor)pagefaults 0swaps

elapsed=`grep elapsed ${errfile} | awk '{print $3}' | sed 's/elapsed//'`
dotindex=`expr index ${elapsed} '.'`
if [ ${dotindex} -ne 0 ]; then
        # less than an hour
        colonindex=`expr index ${elapsed} ':'`
        colonindex=`expr $colonindex - 1`
        hours=0
        mins=`expr substr ${elapsed} 1 ${colonindex}`
        secindex=`expr $colonindex + 2`
        secs=`expr substr ${elapsed} ${secindex} 2`
else
        colonindex=`expr index ${elapsed} ':'`
        colonindex=`expr $colonindex - 1`
        hours=`expr substr ${elapsed} 1 ${colonindex}`
        next=`expr $colonindex + 2`
        rest=`expr substr ${elapsed} $next 999`
        colonindex=`expr index ${rest} ':'`
        colonindex=`expr $colonindex - 1`
        mins=`expr substr ${rest} 1 $colonindex`
        next=`expr $colonindex + 2`
        rest=`expr substr ${rest} $next 999`
        secs=$rest
fi
if [ $secs -ge 30 ]; then
    mins=`expr $mins + 1`
fi

scopsid=`echo ${scopsid} | sed 's/_/\\\_/g'`
printf '%-20s & %-20s & %3d & %4.2f & %d h %02d m ' "${fold}" "\texttt{${scopsid}}" ${numsses} ${auc} ${hours} ${mins}
echo '\\\'

