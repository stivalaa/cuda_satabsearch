#!/usr/bin/env python
###############################################################################
#
# ssepermutationremap.py - Remap SSE mapping output of solns2ssemap.py for the
#                     case that one of the tableaux was row+column permuted.
#
# See usage comment in docstring for main()
#
# File:    ssepermutationremap.py
# Author:  Alex Stivala
# Created: November 2008
#
# $Id: ssepermutationremap.py 2043 2008-11-27 01:54:29Z astivala $
# 
###############################################################################

"""
In the case that one of the tableaux has been row+column permuted
(for testing nonsequential matching)
(-u option on pytableaucreate.py (-u option on 
qptabmatchstructs.sh)) we cannot just use the mapping produced
by soln2ssemap.py (q.v.) as it just numbers sequentially along
the tableau, but this is no longer in the same order as the SSEs in
the structure. So to get the actualy visualization/RMSD calculation
(superimposessemap.py, the next stage in the pipeline) correct,
we have to apply the permutation so that the numbers are mapped
back to the actual SSEs in the structure that that row+column in the
tableau represents.

"""

import sys,os
import getopt
from time import strftime,localtime

from parsessemap import parse_ssemap,SearchMap,QuerySSEMap

#-----------------------------------------------------------------------------
#
# Function definitions
#
#-----------------------------------------------------------------------------


#-----------------------------------------------------------------------------
#
# Main
#
#-----------------------------------------------------------------------------
    
def usage(progname):
    """
    Print usage message and exit
    """
    
    sys.stderr.write("Usage: " +progname + " [-d domainid] permutation_list\n")
    sys.exit(1)

    
def main():
    """
    main for ssepermutationremap.py

    Usage: sol2ssemap.py [-d domainid] permutation_list

    -d domainid: only output result for query against that domain (SCOP)  id,
                 not all.

    permutation_list is the comma-separted list of integers representing 
    the permutation. E.g. (for 4 SSEs) 1,2,3,4 is the null permutation,
    and 4,3,2,1 represents reversing the sequence, etc.
    Note that this must be the same list used to 
    to produce the mapping, i.e. that the tableaux query
    was built with, otherwise it won't mean anything.

    Input is on stdin, the output of soln2ssemap.py,
    format is identifier and score, then
    for each matching a line containing
    i and j separated by a space,
    one per line (with blank line before next id) e.g.:

    # TSRCHD LTYPE = T LORDER = T LSOLN = T
    # QUERY ID = D1KI9A_ 
    # DBFILE = /local/charikar/astivala/tableauxdb/astral/tableauxdb.ascii
    # Mon Aug  4 12:34:07 2008
    d1wiua_     -23.0000
    1 1
    3 2
    8 4
    9 5
    11 6
    14 9

    Note we copy the QUERY ID and DBFILE and other information to output for use
    in later processing.

    Output is the same format, but the SSE numbers in the first column
    have been remapped according to the sse_num_list; i.e. the numbers
    in that column of the input as used as indices into the sse_num_list
    and the resulting numbers from that list are the correspdoning output.
    """
    global verbose
    verbose = False

    dbdomid = None
    
    try:
        opts,args = getopt.getopt(sys.argv[1:], "d:")
    except:
        usage(os.path.basename(sys.argv[0]))
    for opt,arg in opts:
        if opt == "-d": # domain id specified, only get this one
            dbdomid = arg
        else:
            usage(os.path.basename(sys.argv[0]))
        
    if len(args) != 1:
        usage(os.path.basename(sys.argv[0]))

    permut_list_str = args[0].split(',')
    permut_list = []
    sse_id_uniq_dict = {} # { id : True } just for checking all unique
    for sse_id_str in permut_list_str:
        if sse_id_str.isdigit():
            if sse_id_uniq_dict.has_key(int(sse_id_str)):
                sys.stderr.write("duplicate SSE sequential number "  +
                                 sse_id_str + "\n")
                usage(sys.argv[0])
            sse_id_uniq_dict[int(sse_id_str)] = True
            permut_list.append(int(sse_id_str))
        else:
            sys.stderr.write("not a valid SSE sequential number '" +
                             sse_id_str + "'\n")
            usage(sys.argv[0])

    search_maps = parse_ssemap(sys.stdin)

    sys.stdout.write('# generated by ' + os.path.basename(sys.argv[0]) + ' ' + ' '.join(sys.argv[1:]) +'\n')
    timestamp = strftime("%d%b%Y %H:%M:%S", localtime())
    sys.stdout.write('# on ' + timestamp + '\n')
    sys.stdout.write('# from:\n')
    for cline in search_maps.comment_lines:
        sys.stdout.write(cline)
    sys.stdout.write('#\n')    
    for query_ssemap in search_maps.query_ssemap_list:
        if ((not dbdomid) or (query_ssemap.domid == dbdomid)):
            sys.stdout.write('%s %12.4f\n' % (query_ssemap.domid,query_ssemap.score))
            for (i,j) in query_ssemap.sse_map:
                iprime = permut_list[i-1]
                sys.stdout.write(str(iprime) + ' ' + str(j) + '\n')



            
if __name__ == "__main__":
    main()
